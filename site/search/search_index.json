{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Tork Governance SDK","text":"<p>A universal, production-ready governance SDK for AI agents.</p>"},{"location":"#overview","title":"Overview","text":"<p>Tork Governance provides a comprehensive framework for managing AI agent behavior, ensuring security, and maintaining compliance. It handles everything from policy evaluation and PII redaction to security scanning, agent orchestration, and multi-agent coordination.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Governance Engine: Declarative policy evaluation (ALLOW/DENY/REDACT)</li> <li>PII Redactor: Automatic detection and redaction of sensitive data (Email, Phone, SSN, etc.)</li> <li>MCP Security Scanner: Security scanning for agent configurations and code</li> <li>Agent Identity: JWT-based identity management and authentication</li> <li>Compliance Receipts: Tamper-evident audit trails with HMAC signatures</li> <li>Framework Integrations: Native support for LangChain, CrewAI, AutoGen, OpenAI Agents SDK, and HTTP Proxy</li> <li>Workflows: Agent chaining and workflow orchestration with governance</li> <li>Consensus: Multi-agent debate and consensus building system</li> <li>ACL: Agent Communication Language message schema with FIPA protocols</li> <li>Personas: Custom agents/personas with governance-enforced execution</li> <li>Capabilities: Agent capability labels with proficiency levels and task matching</li> <li>Routing: Role/sector-based request routing with governance</li> <li>Prompts: Agent-selectable prompts with multi-agent generation and selection</li> <li>Interactive Playground: Web-based UI for testing policies and scanning</li> </ul>"},{"location":"#test-coverage","title":"Test Coverage","text":"<p>The SDK includes 450+ tests covering all major systems:</p> <ul> <li>Core governance engine and policy evaluation</li> <li>PII detection with 6 data types</li> <li>MCP security scanner with 10 rules</li> <li>JWT identity management</li> <li>Compliance receipts and audit trails</li> <li>5 framework integrations (LangChain, CrewAI, AutoGen, OpenAI Agents, HTTP Proxy)</li> <li>Workflow orchestration</li> <li>Consensus and debate systems</li> <li>ACL message schemas with FIPA protocols</li> <li>Custom personas with templates</li> <li>Capability labels and task matching</li> <li>Role/sector routing</li> <li>Agent-selectable prompts</li> </ul>"},{"location":"#quick-installation","title":"Quick Installation","text":"<pre><code>pip install tork-governance\n</code></pre>"},{"location":"#documentation-map","title":"Documentation Map","text":"Section Description Getting Started Installation and basic usage Framework Integrations LangChain, CrewAI, AutoGen, OpenAI Agents Workflows Agent chaining and orchestration Consensus Multi-agent debate and decision-making ACL Agent Communication Language protocols Personas Custom agent personas Capabilities Agent proficiency labels and matching Routing Role and sector-based routing Prompts Agent-selectable prompt generation API Reference Detailed class and method documentation"},{"location":"#architecture","title":"Architecture","text":"<pre><code>tork-governance/\n\u251c\u2500\u2500 src/tork/\n\u2502   \u251c\u2500\u2500 core/           # Engine, models, policies, redactor\n\u2502   \u251c\u2500\u2500 scanner/        # MCP security scanning\n\u2502   \u251c\u2500\u2500 adapters/       # Framework integrations\n\u2502   \u251c\u2500\u2500 workflows/      # Agent chaining\n\u2502   \u251c\u2500\u2500 consensus/      # Multi-agent debate\n\u2502   \u251c\u2500\u2500 acl/            # Agent Communication Language\n\u2502   \u251c\u2500\u2500 personas/       # Custom personas\n\u2502   \u251c\u2500\u2500 capabilities/   # Agent capability labels\n\u2502   \u251c\u2500\u2500 routing/        # Role/sector routing\n\u2502   \u251c\u2500\u2500 prompts/        # Agent-selectable prompts\n\u2502   \u251c\u2500\u2500 identity/       # JWT authentication\n\u2502   \u251c\u2500\u2500 compliance/     # Audit trails\n\u2502   \u2514\u2500\u2500 api/            # FastAPI endpoints\n</code></pre>"},{"location":"acl/","title":"Agent Communication Language (ACL)","text":"<p>Structured message passing between AI agents using FIPA-compliant protocols.</p>"},{"location":"acl/#overview","title":"Overview","text":"<p>The ACL module provides a standardized way for AI agents to communicate using performatives (speech acts), structured messages, and formal protocols. All messages pass through governance and generate compliance receipts.</p>"},{"location":"acl/#core-concepts","title":"Core Concepts","text":""},{"location":"acl/#performatives","title":"Performatives","text":"<p>The 12 standard speech acts for agent communication:</p> <pre><code>from tork.acl import Performative\n\n# Requesting and informing\nPerformative.REQUEST       # Ask agent to perform action\nPerformative.INFORM        # Share information\nPerformative.QUERY_IF      # Ask if something is true\nPerformative.QUERY_REF     # Ask for a value\n\n# Proposing and negotiating\nPerformative.PROPOSE       # Make a proposal\nPerformative.ACCEPT        # Accept a proposal\nPerformative.REJECT        # Reject a proposal\n\n# Task management\nPerformative.CFP           # Call for proposals\nPerformative.AGREE         # Agree to perform action\nPerformative.REFUSE        # Refuse to perform action\nPerformative.CANCEL        # Cancel a request\nPerformative.FAILURE       # Report failure\n</code></pre>"},{"location":"acl/#aclmessage","title":"ACLMessage","text":"<p>Structured message format:</p> <pre><code>from tork.acl import ACLMessage, Performative\n\nmessage = ACLMessage(\n    performative=Performative.REQUEST,\n    sender=\"coordinator\",\n    receiver=\"worker-1\",\n    content={\"task\": \"analyze_data\", \"file\": \"data.csv\"},\n    protocol=\"fipa-request\",\n    ontology=\"data-analysis\",\n    conversation_id=\"conv-123\",\n)\n</code></pre>"},{"location":"acl/#messagebuilder","title":"MessageBuilder","text":"<p>Fluent API for creating messages:</p> <pre><code>from tork.acl import MessageBuilder\n\nmessage = (\n    MessageBuilder()\n    .request()\n    .from_agent(\"coordinator\")\n    .to_agent(\"worker-1\")\n    .with_content({\"task\": \"process\"})\n    .using_protocol(\"fipa-request\")\n    .in_conversation(\"conv-123\")\n    .build()\n)\n</code></pre>"},{"location":"acl/#fipa-protocols","title":"FIPA Protocols","text":""},{"location":"acl/#request-protocol","title":"Request Protocol","text":"<p>Simple request-response pattern:</p> <pre><code>from tork.acl import FIPAProtocol\n\nprotocol = FIPAProtocol.REQUEST\n\n# States: INITIATED -&gt; AGREED/REFUSED -&gt; COMPLETED/FAILED\n</code></pre>"},{"location":"acl/#contract-net-protocol","title":"Contract Net Protocol","text":"<p>Negotiation for task assignment:</p> <pre><code>from tork.acl import FIPAProtocol\n\nprotocol = FIPAProtocol.CONTRACT_NET\n\n# Flow:\n# 1. Initiator sends CFP (Call for Proposals)\n# 2. Participants send PROPOSE or REFUSE\n# 3. Initiator sends ACCEPT or REJECT\n# 4. Winner sends INFORM (result) or FAILURE\n</code></pre>"},{"location":"acl/#query-protocol","title":"Query Protocol","text":"<p>Information retrieval:</p> <pre><code>from tork.acl import FIPAProtocol\n\nprotocol = FIPAProtocol.QUERY\n\n# States: INITIATED -&gt; INFORMED/REFUSED\n</code></pre>"},{"location":"acl/#aclrouter","title":"ACLRouter","text":"<p>Route messages between agents with governance:</p> <pre><code>from tork.acl import ACLRouter\n\nrouter = ACLRouter()\n\n# Register message handlers\nrouter.register_handler(\"worker-1\", worker1_handler)\nrouter.register_handler(\"worker-2\", worker2_handler)\n\n# Route a message\nresponse = router.route(message)\n\n# Broadcast to multiple agents\nresponses = router.broadcast(\n    message,\n    receivers=[\"worker-1\", \"worker-2\", \"worker-3\"],\n)\n</code></pre>"},{"location":"acl/#conversation-management","title":"Conversation Management","text":"<p>Track message threads:</p> <pre><code>from tork.acl import Conversation\n\nconversation = Conversation(id=\"conv-123\")\n\n# Add messages\nconversation.add_message(request_message)\nconversation.add_message(response_message)\n\n# Get conversation history\nfor msg in conversation.messages:\n    print(f\"{msg.sender} -&gt; {msg.receiver}: {msg.performative}\")\n\n# Check conversation state\nprint(f\"State: {conversation.state}\")\nprint(f\"Is complete: {conversation.is_complete}\")\n</code></pre>"},{"location":"acl/#protocol-validation","title":"Protocol Validation","text":"<p>Ensure messages follow protocol rules:</p> <pre><code>from tork.acl import validate_protocol_transition\n\n# Check if a transition is valid\nis_valid = validate_protocol_transition(\n    protocol=FIPAProtocol.REQUEST,\n    current_state=\"INITIATED\",\n    message_type=Performative.AGREE,\n)\n\nif not is_valid:\n    raise ValueError(\"Invalid protocol transition\")\n</code></pre>"},{"location":"acl/#governance-integration","title":"Governance Integration","text":"<p>All messages pass through governance:</p> <pre><code>from tork.core import GovernanceEngine\nfrom tork.acl import ACLRouter\n\ngov_engine = GovernanceEngine(policies=[security_policy])\nrouter = ACLRouter(governance_engine=gov_engine)\n\n# Messages with PII will be redacted\n# Blocked actions will be denied\nresponse = router.route(message)\n</code></pre>"},{"location":"acl/#compliance-receipts","title":"Compliance Receipts","text":"<p>Each message generates a signed receipt:</p> <pre><code>response = router.route(message)\n\nprint(f\"Receipt ID: {response.receipt.receipt_id}\")\nprint(f\"Sender: {response.receipt.agent_id}\")\nprint(f\"Signature: {response.receipt.signature}\")\n</code></pre>"},{"location":"acl/#example-contract-net-negotiation","title":"Example: Contract Net Negotiation","text":"<pre><code>from tork.acl import MessageBuilder, ACLRouter, Performative\n\nrouter = ACLRouter()\n\n# 1. Send Call for Proposals\ncfp = (\n    MessageBuilder()\n    .cfp()\n    .from_agent(\"manager\")\n    .to_agent(\"worker-1\")\n    .with_content({\"task\": \"process_batch\", \"deadline\": \"1h\"})\n    .using_protocol(\"fipa-contract-net\")\n    .build()\n)\n\n# 2. Receive proposals\nproposal = router.route(cfp)\n\n# 3. Accept best proposal\naccept = (\n    MessageBuilder()\n    .accept()\n    .from_agent(\"manager\")\n    .to_agent(\"worker-1\")\n    .with_content({\"selected\": True})\n    .in_conversation(cfp.conversation_id)\n    .build()\n)\n\n# 4. Get result\nresult = router.route(accept)\n</code></pre>"},{"location":"api-reference/","title":"API Reference","text":"<p>Detailed documentation for the Tork Governance SDK core components.</p>"},{"location":"api-reference/#governanceengine","title":"GovernanceEngine","text":"<p>The main entry point for policy evaluation.</p>"},{"location":"api-reference/#methods","title":"Methods","text":"<ul> <li><code>evaluate(payload: Dict, agent_id: str = None) -&gt; EvaluationResult</code>: Evaluates a payload against all loaded policies.</li> <li><code>add_policy(policy: Policy)</code>: Manually adds a policy to the engine.</li> </ul>"},{"location":"api-reference/#piiredactor","title":"PIIRedactor","text":"<p>Handles detection and redaction of sensitive information.</p>"},{"location":"api-reference/#methods_1","title":"Methods","text":"<ul> <li><code>redact(text: str, pii_types: List[str] = None) -&gt; str</code>: Detects and redacts PII from text.</li> <li><code>detect(text: str) -&gt; List[PIIMatch]</code>: Returns a list of detected PII matches without redacting.</li> </ul>"},{"location":"api-reference/#mcpscanner","title":"MCPScanner","text":"<p>Security scanner for configuration and source files.</p>"},{"location":"api-reference/#methods_2","title":"Methods","text":"<ul> <li><code>scan_content(content: str, filename: str) -&gt; List[ScanFinding]</code>: Scans text content for security vulnerabilities.</li> <li><code>scan_directory(path: str) -&gt; List[ScanFinding]</code>: Scans all supported files in a directory.</li> </ul>"},{"location":"api-reference/#identityhandler","title":"IdentityHandler","text":"<p>Manages agent identity and JWT tokens.</p>"},{"location":"api-reference/#methods_3","title":"Methods","text":"<ul> <li><code>issue_token(agent_id: str, permissions: List[str]) -&gt; str</code>: Creates a new JWT for an agent.</li> <li><code>verify_token(token: str) -&gt; Dict</code>: Validates a token and returns its claims.</li> </ul>"},{"location":"api-reference/#policy-models","title":"Policy Models","text":""},{"location":"api-reference/#policy","title":"Policy","text":"<ul> <li><code>name</code>: Unique name for the policy.</li> <li><code>rules</code>: List of <code>Rule</code> objects.</li> <li><code>priority</code>: Execution priority (lower numbers run first).</li> </ul>"},{"location":"api-reference/#rule","title":"Rule","text":"<ul> <li><code>field</code>: The payload field to evaluate (supports dot notation).</li> <li><code>operator</code>: The comparison operator (equals, contains, regex, etc.).</li> <li><code>value</code>: The target value for the comparison.</li> <li><code>action</code>: Resulting action (ALLOW, DENY, REDACT).</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>Detailed documentation of all Tork Governance classes and methods.</p>"},{"location":"api/#core-module","title":"Core Module","text":""},{"location":"api/#governanceengine","title":"GovernanceEngine","text":"<p>The main entry point for policy evaluation.</p> <pre><code>from tork import GovernanceEngine\n\nengine = GovernanceEngine(policies=None, auto_redact=True)\n</code></pre> <p>Parameters: - <code>policies</code>: List of Policy objects (optional) - <code>auto_redact</code>: Enable automatic PII redaction (default: True)</p> <p>Methods:</p> Method Description <code>evaluate(request)</code> Evaluate a request against policies <code>add_policy(policy)</code> Add a policy to the engine <code>remove_policy(name)</code> Remove a policy by name"},{"location":"api/#evaluationrequest","title":"EvaluationRequest","text":"<p>Request model for policy evaluation.</p> <pre><code>from tork.core.models import EvaluationRequest\n\nrequest = EvaluationRequest(\n    payload=dict,           # The data to evaluate\n    agent_id=str,           # Agent identifier\n    action=str,             # Action being performed\n    metadata=dict,          # Optional metadata\n)\n</code></pre>"},{"location":"api/#policydecision","title":"PolicyDecision","text":"<p>Enum for evaluation decisions.</p> <pre><code>from tork.core.models import PolicyDecision\n\nPolicyDecision.ALLOW   # Request is allowed\nPolicyDecision.DENY    # Request is denied\nPolicyDecision.REDACT  # Request allowed with modifications\n</code></pre>"},{"location":"api/#pii-redactor","title":"PII Redactor","text":""},{"location":"api/#piiredactor","title":"PIIRedactor","text":"<p>Detect and redact personally identifiable information.</p> <pre><code>from tork.core.redactor import PIIRedactor\n\nredactor = PIIRedactor()\n</code></pre> <p>Methods:</p> Method Description <code>detect(text)</code> Find PII in text, returns list of PIIMatch <code>redact_text(text)</code> Redact PII from text string <code>redact_dict(data)</code> Recursively redact PII from dict <p>Supported PII Types: - <code>EMAIL</code> - Email addresses - <code>PHONE</code> - Phone numbers - <code>SSN</code> - Social Security Numbers - <code>CREDIT_CARD</code> - Credit card numbers (with Luhn validation) - <code>IP_ADDRESS</code> - IP addresses - <code>API_KEY</code> - API keys and secrets</p>"},{"location":"api/#scanner","title":"Scanner","text":""},{"location":"api/#mcpscanner","title":"MCPScanner","text":"<p>Security scanner for agent configurations.</p> <pre><code>from tork.scanner import MCPScanner\n\nscanner = MCPScanner(severity_filter=None)\n</code></pre> <p>Methods:</p> Method Description <code>scan_file(path)</code> Scan a single file <code>scan_directory(path)</code> Scan all files in directory <code>scan_content(content)</code> Scan content string"},{"location":"api/#identity","title":"Identity","text":""},{"location":"api/#identityhandler","title":"IdentityHandler","text":"<p>JWT-based agent identity management.</p> <pre><code>from tork.identity import IdentityHandler\n\nhandler = IdentityHandler(secret_key=\"your-secret\")\n</code></pre> <p>Methods:</p> Method Description <code>issue_token(agent_id)</code> Issue a JWT token <code>verify_token(token)</code> Verify and decode token <code>revoke_token(token)</code> Revoke a token <code>register_agent(agent_id)</code> Register a new agent"},{"location":"api/#workflows","title":"Workflows","text":""},{"location":"api/#workflowengine","title":"WorkflowEngine","text":"<p>Execute multi-step agent workflows.</p> <pre><code>from tork.workflows import WorkflowEngine\n\nengine = WorkflowEngine(governance_engine=None)\n</code></pre> <p>Methods:</p> Method Description <code>register_executor(agent_id, fn)</code> Register an agent executor <code>execute(workflow, input)</code> Execute a workflow <code>execute_async(workflow, input)</code> Async execution <code>pause(workflow_id)</code> Pause at approval gate <code>resume(workflow_id)</code> Resume paused workflow"},{"location":"api/#workflowbuilder","title":"WorkflowBuilder","text":"<p>Fluent API for building workflows.</p> <pre><code>from tork.workflows import WorkflowBuilder\n\nworkflow = (\n    WorkflowBuilder(\"my-workflow\")\n    .add_step(id=\"step1\", name=\"Step 1\", agent_id=\"agent-1\")\n    .with_max_cost(5.0)\n    .build()\n)\n</code></pre>"},{"location":"api/#consensus","title":"Consensus","text":""},{"location":"api/#debateengine","title":"DebateEngine","text":"<p>Orchestrate multi-agent debates.</p> <pre><code>from tork.consensus import DebateEngine\n\nengine = DebateEngine(governance_engine=None)\n</code></pre> <p>Methods:</p> Method Description <code>register_executor(agent_id, fn)</code> Register an agent executor <code>debate(topic, participants, config)</code> Run a debate"},{"location":"api/#acl","title":"ACL","text":""},{"location":"api/#aclrouter","title":"ACLRouter","text":"<p>Route messages between agents.</p> <pre><code>from tork.acl import ACLRouter\n\nrouter = ACLRouter(governance_engine=None)\n</code></pre> <p>Methods:</p> Method Description <code>register_handler(agent_id, fn)</code> Register message handler <code>route(message)</code> Route a single message <code>broadcast(message, receivers)</code> Send to multiple agents"},{"location":"api/#messagebuilder","title":"MessageBuilder","text":"<p>Fluent API for creating ACL messages.</p> <pre><code>from tork.acl import MessageBuilder\n\nmessage = (\n    MessageBuilder()\n    .request()\n    .from_agent(\"sender\")\n    .to_agent(\"receiver\")\n    .with_content({\"task\": \"...\"})\n    .build()\n)\n</code></pre>"},{"location":"api/#personas","title":"Personas","text":""},{"location":"api/#personaruntime","title":"PersonaRuntime","text":"<p>Execute custom personas.</p> <pre><code>from tork.personas import PersonaRuntime\n\nruntime = PersonaRuntime(governance_engine=None)\n</code></pre> <p>Methods:</p> Method Description <code>register_executor(model, fn)</code> Register model executor <code>execute(persona_id, input, store)</code> Execute a persona <code>start_session(persona_id, store)</code> Start a session <code>end_session(session)</code> End a session"},{"location":"api/#personabuilder","title":"PersonaBuilder","text":"<p>Fluent API for building personas.</p> <pre><code>from tork.personas import PersonaBuilder\n\nconfig = (\n    PersonaBuilder(\"my-persona\")\n    .with_name(\"My Persona\")\n    .with_system_prompt(\"...\")\n    .with_capabilities([...])\n    .build()\n)\n</code></pre>"},{"location":"api/#capabilities","title":"Capabilities","text":""},{"location":"api/#capabilityregistry","title":"CapabilityRegistry","text":"<p>Manage agent capability profiles.</p> <pre><code>from tork.capabilities import CapabilityRegistry\n\nregistry = CapabilityRegistry()\n</code></pre> <p>Methods:</p> Method Description <code>register(profile)</code> Register an agent profile <code>get(agent_id)</code> Get profile by ID <code>list_all()</code> List all profiles <code>filter_by_capability(name, level)</code> Filter by capability <code>compare(agent_ids)</code> Compare multiple agents"},{"location":"api/#taskmatcher","title":"TaskMatcher","text":"<p>Match tasks to best agents.</p> <pre><code>from tork.capabilities import TaskMatcher\n\nmatcher = TaskMatcher(registry)\n</code></pre> <p>Methods:</p> Method Description <code>match(task, capabilities)</code> Find best agent <code>rank(task, capabilities)</code> Rank all agents <code>recommend(task)</code> Get recommendations"},{"location":"api/#routing","title":"Routing","text":""},{"location":"api/#sectorrouter","title":"SectorRouter","text":"<p>Route requests by sector and role.</p> <pre><code>from tork.routing import SectorRouter\n\nrouter = SectorRouter(fallback_route=None)\n</code></pre> <p>Methods:</p> Method Description <code>register_route(sector, roles, config)</code> Register a route <code>route(context, request)</code> Route a request <code>route_by_sector(sector, request)</code> Route by sector only <code>route_by_role(role, request)</code> Route by role only"},{"location":"api/#prompts","title":"Prompts","text":""},{"location":"api/#promptorchestrator","title":"PromptOrchestrator","text":"<p>End-to-end prompt generation and selection.</p> <pre><code>from tork.prompts import PromptOrchestrator\n\norchestrator = PromptOrchestrator()\n</code></pre> <p>Methods:</p> Method Description <code>orchestrate(task, type, agents)</code> Generate and select <code>refine(prompt, agent, feedback)</code> Refine a prompt <code>iterate(task, agents, max_iter)</code> Iterative improvement"},{"location":"capabilities/","title":"Capabilities","text":"<p>Agent capability labels with proficiency levels and task matching.</p>"},{"location":"capabilities/#overview","title":"Overview","text":"<p>The Capabilities module provides a system for labeling AI agents with their capabilities and proficiency levels, then matching tasks to the best-suited agents. This enables intelligent task routing based on agent strengths.</p>"},{"location":"capabilities/#core-concepts","title":"Core Concepts","text":""},{"location":"capabilities/#capabilitylevel","title":"CapabilityLevel","text":"<p>Four proficiency levels:</p> <pre><code>from tork.capabilities import CapabilityLevel\n\nCapabilityLevel.BASIC        # Entry-level proficiency\nCapabilityLevel.INTERMEDIATE # Moderate proficiency\nCapabilityLevel.ADVANCED     # High proficiency\nCapabilityLevel.EXPERT       # Top-tier proficiency\n</code></pre>"},{"location":"capabilities/#performancemetric","title":"PerformanceMetric","text":"<p>Six performance dimensions:</p> <pre><code>from tork.capabilities import PerformanceMetric\n\nPerformanceMetric.SPEED      # Response latency\nPerformanceMetric.ACCURACY   # Correctness of outputs\nPerformanceMetric.CREATIVITY # Novel solutions\nPerformanceMetric.SAFETY     # Avoiding harmful outputs\nPerformanceMetric.COST       # Token/API efficiency\nPerformanceMetric.CONTEXT    # Long context handling\n</code></pre>"},{"location":"capabilities/#agentcapability","title":"AgentCapability","text":"<p>Define a single capability:</p> <pre><code>from tork.capabilities import AgentCapability, CapabilityLevel\n\ncapability = AgentCapability(\n    name=\"code_generation\",\n    level=CapabilityLevel.EXPERT,\n    score=0.95,\n    verified=True,\n)\n</code></pre>"},{"location":"capabilities/#agentprofile","title":"AgentProfile","text":"<p>Complete agent profile with capabilities and metrics:</p> <pre><code>from tork.capabilities import AgentProfile, PerformanceMetric\n\nprofile = AgentProfile(\n    agent_id=\"gpt-4\",\n    model=\"gpt-4\",\n    capabilities=[\n        AgentCapability(\"reasoning\", CapabilityLevel.EXPERT, 0.95),\n        AgentCapability(\"coding\", CapabilityLevel.ADVANCED, 0.85),\n        AgentCapability(\"creative_writing\", CapabilityLevel.ADVANCED, 0.80),\n    ],\n    performance_metrics={\n        PerformanceMetric.ACCURACY: 0.92,\n        PerformanceMetric.SAFETY: 0.95,\n        PerformanceMetric.COST: 0.3,  # Higher cost\n    },\n    strengths=[\"complex reasoning\", \"code analysis\"],\n    weaknesses=[\"real-time data\", \"image generation\"],\n)\n</code></pre>"},{"location":"capabilities/#capabilityregistry","title":"CapabilityRegistry","text":"<p>Manage agent profiles:</p> <pre><code>from tork.capabilities import CapabilityRegistry\n\nregistry = CapabilityRegistry()\n\n# Register profiles\nregistry.register(gpt4_profile)\nregistry.register(claude_profile)\nregistry.register(llama_profile)\n\n# Get a profile\nprofile = registry.get(\"gpt-4\")\n\n# List all profiles\nall_profiles = registry.list_all()\n\n# Filter by capability\ncoders = registry.filter_by_capability(\"coding\", min_level=CapabilityLevel.ADVANCED)\n\n# Filter by metric threshold\nfast_agents = registry.filter_by_metric(PerformanceMetric.SPEED, min_score=0.8)\n</code></pre>"},{"location":"capabilities/#compare-agents","title":"Compare Agents","text":"<p>Compare capabilities between agents:</p> <pre><code>comparison = registry.compare([\"gpt-4\", \"claude-3-opus\"])\n\nfor agent_id, profile in comparison.items():\n    print(f\"{agent_id}:\")\n    for cap in profile.capabilities:\n        print(f\"  {cap.name}: {cap.level.value} ({cap.score})\")\n</code></pre>"},{"location":"capabilities/#taskmatcher","title":"TaskMatcher","text":"<p>Find the best agent for a task:</p> <pre><code>from tork.capabilities import TaskMatcher\n\nmatcher = TaskMatcher(registry)\n\n# Define task requirements\nresult = matcher.match(\n    task_description=\"Generate Python code for a REST API\",\n    required_capabilities=[\"coding\", \"api_design\"],\n    min_level=CapabilityLevel.ADVANCED,\n    performance_priorities={\n        PerformanceMetric.ACCURACY: 0.5,\n        PerformanceMetric.SPEED: 0.3,\n        PerformanceMetric.COST: 0.2,\n    },\n)\n\nprint(f\"Best agent: {result.best_match}\")\nprint(f\"Confidence: {result.confidence}\")\nprint(f\"Reasoning: {result.reasoning}\")\n</code></pre>"},{"location":"capabilities/#rank-multiple-agents","title":"Rank Multiple Agents","text":"<p>Get a ranked list of suitable agents:</p> <pre><code>rankings = matcher.rank(\n    task_description=\"Analyze legal documents\",\n    required_capabilities=[\"legal_analysis\", \"summarization\"],\n)\n\nfor rank, (agent_id, score) in enumerate(rankings, 1):\n    print(f\"{rank}. {agent_id}: {score:.2f}\")\n</code></pre>"},{"location":"capabilities/#get-recommendations","title":"Get Recommendations","text":"<p>Get detailed recommendations:</p> <pre><code>recommendations = matcher.recommend(\n    task_description=\"Creative marketing copy\",\n    max_results=3,\n)\n\nfor rec in recommendations:\n    print(f\"Agent: {rec.agent_id}\")\n    print(f\"Score: {rec.score}\")\n    print(f\"Strengths for task: {rec.relevant_strengths}\")\n    print(f\"Potential issues: {rec.potential_issues}\")\n</code></pre>"},{"location":"capabilities/#default-profiles","title":"Default Profiles","text":"<p>Pre-configured profiles for popular models:</p> <pre><code>from tork.capabilities.defaults import (\n    gpt4_profile,\n    gpt4_turbo_profile,\n    claude3_opus_profile,\n    claude3_sonnet_profile,\n    gemini_pro_profile,\n    llama3_profile,\n)\n\nregistry = CapabilityRegistry()\n\n# Load all defaults\nregistry.register(gpt4_profile())\nregistry.register(gpt4_turbo_profile())\nregistry.register(claude3_opus_profile())\nregistry.register(claude3_sonnet_profile())\nregistry.register(gemini_pro_profile())\nregistry.register(llama3_profile())\n</code></pre>"},{"location":"capabilities/#default-profile-characteristics","title":"Default Profile Characteristics","text":"Model Strengths Cost GPT-4 Reasoning, coding, analysis High GPT-4 Turbo Speed, long context Medium Claude 3 Opus Safety, nuance, writing High Claude 3 Sonnet Balance of speed/quality Medium Gemini Pro Multimodal, reasoning Medium Llama 3 Open source, customizable Low"},{"location":"capabilities/#example-building-a-task-router","title":"Example: Building a Task Router","text":"<pre><code>from tork.capabilities import CapabilityRegistry, TaskMatcher\nfrom tork.capabilities.defaults import (\n    gpt4_profile,\n    claude3_opus_profile,\n    llama3_profile,\n)\n\n# Set up registry with available models\nregistry = CapabilityRegistry()\nregistry.register(gpt4_profile())\nregistry.register(claude3_opus_profile())\nregistry.register(llama3_profile())\n\n# Create matcher\nmatcher = TaskMatcher(registry)\n\n# Route different tasks\ndef route_task(task: str, capabilities: list[str]) -&gt; str:\n    result = matcher.match(\n        task_description=task,\n        required_capabilities=capabilities,\n    )\n    return result.best_match\n\n# Examples\ncode_agent = route_task(\"Write a Python script\", [\"coding\"])\nlegal_agent = route_task(\"Analyze this contract\", [\"legal_analysis\"])\ncreative_agent = route_task(\"Write a poem\", [\"creative_writing\"])\n</code></pre>"},{"location":"capabilities/#integration-with-routing","title":"Integration with Routing","text":"<p>Combine with the Routing module:</p> <pre><code>from tork.capabilities import TaskMatcher\nfrom tork.routing import SectorRouter\n\n# Match capabilities first\nbest_agent = matcher.match(task, capabilities).best_match\n\n# Then route based on sector\nrouter = SectorRouter()\nroute = router.route(context, target_agent=best_agent)\n</code></pre>"},{"location":"consensus/","title":"Consensus","text":"<p>Multi-agent debate and consensus building system.</p>"},{"location":"consensus/#overview","title":"Overview","text":"<p>The Consensus module enables multiple AI agents to debate topics, critique each other's responses, and reach consensus through various strategies. All responses are governed by policies and generate compliance receipts.</p>"},{"location":"consensus/#core-concepts","title":"Core Concepts","text":""},{"location":"consensus/#debateparticipant","title":"DebateParticipant","text":"<p>Define agents that participate in debates:</p> <pre><code>from tork.consensus import DebateParticipant, ParticipantRole\n\nparticipant = DebateParticipant(\n    agent_id=\"expert-1\",\n    role=ParticipantRole.DEBATER,\n    voting_weight=1.0,\n    model=\"gpt-4\",\n)\n</code></pre>"},{"location":"consensus/#participant-roles","title":"Participant Roles","text":"<ul> <li><code>DEBATER</code>: Presents arguments and positions</li> <li><code>CRITIC</code>: Critiques other participants' arguments</li> <li><code>SYNTHESIZER</code>: Combines multiple perspectives</li> <li><code>JUDGE</code>: Makes final decisions</li> </ul>"},{"location":"consensus/#consensusconfig","title":"ConsensusConfig","text":"<p>Configure how consensus is reached:</p> <pre><code>from tork.consensus import ConsensusConfig, ConsensusMethod\n\nconfig = ConsensusConfig(\n    method=ConsensusMethod.SYNTHESIS,\n    max_rounds=3,\n    stop_on_consensus=True,\n    cost_limit=5.0,\n)\n</code></pre>"},{"location":"consensus/#debateengine","title":"DebateEngine","text":"<p>Orchestrate multi-agent debates:</p> <pre><code>from tork.consensus import DebateEngine\n\nengine = DebateEngine()\n\n# Register agent executors\nengine.register_executor(\"expert-1\", expert1_fn)\nengine.register_executor(\"expert-2\", expert2_fn)\nengine.register_executor(\"synthesizer\", synthesizer_fn)\n\n# Run debate\nresult = engine.debate(\n    topic=\"Should AI systems be open source?\",\n    participants=[participant1, participant2, synthesizer],\n    config=config,\n)\n\nprint(f\"Consensus: {result.consensus}\")\nprint(f\"Rounds: {len(result.rounds)}\")\n</code></pre>"},{"location":"consensus/#consensus-strategies","title":"Consensus Strategies","text":""},{"location":"consensus/#synthesis-strategy","title":"Synthesis Strategy","text":"<p>Combines all perspectives into a unified view:</p> <pre><code>config = ConsensusConfig(method=ConsensusMethod.SYNTHESIS)\n\n# A synthesizer agent combines all arguments\nresult = engine.debate(topic, participants, config)\n</code></pre>"},{"location":"consensus/#voting-strategy","title":"Voting Strategy","text":"<p>Participants vote on the best position:</p> <pre><code>config = ConsensusConfig(\n    method=ConsensusMethod.VOTING,\n    voting_threshold=0.6,  # 60% agreement required\n)\n\nresult = engine.debate(topic, participants, config)\nprint(f\"Votes: {result.vote_counts}\")\n</code></pre>"},{"location":"consensus/#judge-strategy","title":"Judge Strategy","text":"<p>A designated judge makes the final decision:</p> <pre><code>judge = DebateParticipant(\n    agent_id=\"judge\",\n    role=ParticipantRole.JUDGE,\n)\n\nconfig = ConsensusConfig(method=ConsensusMethod.JUDGE)\n\nresult = engine.debate(\n    topic,\n    participants=[debater1, debater2, judge],\n    config,\n)\n</code></pre>"},{"location":"consensus/#unanimous-strategy","title":"Unanimous Strategy","text":"<p>All participants must agree:</p> <pre><code>config = ConsensusConfig(\n    method=ConsensusMethod.UNANIMOUS,\n    max_rounds=5,  # Keep debating until unanimous or max rounds\n)\n</code></pre>"},{"location":"consensus/#debate-rounds","title":"Debate Rounds","text":"<p>Track the debate progression:</p> <pre><code>result = engine.debate(topic, participants, config)\n\nfor round in result.rounds:\n    print(f\"Round {round.round_number}:\")\n    for response in round.responses:\n        print(f\"  {response.agent_id}: {response.content[:100]}...\")\n    for critique in round.critiques:\n        print(f\"  Critique from {critique.agent_id}\")\n</code></pre>"},{"location":"consensus/#cost-limit-enforcement","title":"Cost Limit Enforcement","text":"<p>Stop debates when budget is exceeded:</p> <pre><code>config = ConsensusConfig(\n    method=ConsensusMethod.SYNTHESIS,\n    cost_limit=2.0,  # Stop if cost exceeds $2\n)\n\nresult = engine.debate(topic, participants, config)\n\nif result.cost_exceeded:\n    print(f\"Stopped due to cost limit: ${result.total_cost}\")\n</code></pre>"},{"location":"consensus/#pre-built-templates","title":"Pre-built Templates","text":"<p>Ready-to-use debate configurations:</p> <pre><code>from tork.consensus.templates import (\n    two_agent_critique,\n    three_way_debate,\n    expert_panel,\n)\n\n# Two agents critique each other\nparticipants, config = two_agent_critique()\n\n# Three-way debate with synthesis\nparticipants, config = three_way_debate()\n\n# Expert panel with multiple specialists and a moderator\nparticipants, config = expert_panel(\n    expert_ids=[\"legal\", \"technical\", \"business\"],\n    moderator_id=\"moderator\",\n)\n</code></pre>"},{"location":"consensus/#governance-integration","title":"Governance Integration","text":"<p>All debate responses pass through governance:</p> <pre><code>from tork.core import GovernanceEngine\n\ngov_engine = GovernanceEngine(policies=[pii_policy])\ndebate_engine = DebateEngine(governance_engine=gov_engine)\n\n# PII will be redacted from all responses\nresult = debate_engine.debate(topic, participants, config)\n</code></pre>"},{"location":"consensus/#compliance-receipts","title":"Compliance Receipts","text":"<p>Each response generates a signed receipt:</p> <pre><code>for round in result.rounds:\n    for response in round.responses:\n        print(f\"Receipt: {response.receipt.receipt_id}\")\n        print(f\"Verified: {response.receipt.verify()}\")\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>Practical examples of using the Tork Governance SDK.</p>"},{"location":"examples/#pii-redaction","title":"PII Redaction","text":"<pre><code>from tork.core.redactor import PIIRedactor\n\nredactor = PIIRedactor()\ntext = \"Contact me at alice@example.com\"\nredacted = redactor.redact(text)\n# Result: \"Contact me at [EMAIL]\"\n</code></pre>"},{"location":"examples/#security-scanning","title":"Security Scanning","text":"<pre><code>from tork.scanner.scanner import MCPScanner\n\nscanner = MCPScanner()\nfindings = scanner.scan_content('{\"api_key\": \"sk-12345\"}', \"config.json\")\n# findings will contain a 'Hardcoded Secret' vulnerability\n</code></pre>"},{"location":"examples/#receipt-generation","title":"Receipt Generation","text":"<pre><code>from tork.compliance.receipts import ReceiptGenerator\n\ngenerator = ReceiptGenerator(secret_key=\"secret\")\nreceipt = generator.create_receipt(agent_id=\"agent-1\", result=eval_result)\n# receipt contains an HMAC signature for tamper-proofing\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Get up and running with Tork Governance in minutes.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code>pip install tork-governance\n</code></pre> <p>For optional framework integrations:</p> <pre><code>pip install tork-governance[langchain]    # LangChain integration\npip install tork-governance[crewai]       # CrewAI integration\npip install tork-governance[autogen]      # AutoGen integration\npip install tork-governance[openai]       # OpenAI Agents SDK\npip install tork-governance[all]          # All integrations\n</code></pre>"},{"location":"getting-started/#quick-start","title":"Quick Start","text":""},{"location":"getting-started/#basic-policy-evaluation","title":"Basic Policy Evaluation","text":"<pre><code>from tork import GovernanceEngine\nfrom tork.core.models import EvaluationRequest, PolicyDecision\n\n# Create engine\nengine = GovernanceEngine()\n\n# Evaluate a request\nrequest = EvaluationRequest(\n    payload={\"message\": \"Hello world\"},\n    agent_id=\"my-agent\",\n    action=\"chat\",\n)\n\nresult = engine.evaluate(request)\n\nif result.decision == PolicyDecision.ALLOW:\n    print(\"Request allowed\")\nelif result.decision == PolicyDecision.DENY:\n    print(\"Request denied\")\nelif result.decision == PolicyDecision.REDACT:\n    print(f\"Redacted: {result.modified_payload}\")\n</code></pre>"},{"location":"getting-started/#pii-redaction","title":"PII Redaction","text":"<pre><code>from tork.core.redactor import PIIRedactor\n\nredactor = PIIRedactor()\n\ntext = \"Contact john@example.com or call 555-123-4567\"\nredacted = redactor.redact_text(text)\nprint(redacted)  # Contact [EMAIL REDACTED] or call [PHONE REDACTED]\n</code></pre>"},{"location":"getting-started/#security-scanning","title":"Security Scanning","text":"<pre><code>from tork.scanner import MCPScanner\n\nscanner = MCPScanner()\nresults = scanner.scan_file(\"config.yaml\")\n\nfor finding in results:\n    print(f\"{finding.severity}: {finding.message}\")\n</code></pre>"},{"location":"getting-started/#core-concepts","title":"Core Concepts","text":""},{"location":"getting-started/#policies","title":"Policies","text":"<p>Policies define rules for allowing, denying, or redacting content:</p> <pre><code>name: content-filter\npriority: 10\nrules:\n  - field: \"message\"\n    operator: \"contains\"\n    value: \"spam\"\n    action: \"DENY\"\n</code></pre>"},{"location":"getting-started/#agents","title":"Agents","text":"<p>Every request is associated with an agent ID for tracking and auditing:</p> <pre><code>request = EvaluationRequest(\n    payload={\"data\": \"...\"},\n    agent_id=\"assistant-v1\",  # Track which agent made this request\n    action=\"process\",\n)\n</code></pre>"},{"location":"getting-started/#compliance-receipts","title":"Compliance Receipts","text":"<p>All evaluations generate tamper-evident receipts:</p> <pre><code>result = engine.evaluate(request)\nreceipt = result.receipt\n\nprint(f\"Receipt ID: {receipt.receipt_id}\")\nprint(f\"Verified: {receipt.verify()}\")\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Framework Integrations - LangChain, CrewAI, AutoGen, OpenAI</li> <li>Workflows - Multi-step agent orchestration</li> <li>Personas - Custom AI personas</li> <li>API Reference - Detailed documentation</li> </ul>"},{"location":"integrations/","title":"Integration Guides","text":"<p>Learn how to integrate Tork Governance into your existing workflows.</p>"},{"location":"integrations/#langchain-middleware","title":"LangChain Middleware","text":"<p>Protect your LangChain agents with a few lines of code:</p> <pre><code>from tork.adapters.langchain import GovernedChain\nfrom langchain.chains import LLMChain\n\n# Wrap your existing chain\ngoverned_chain = GovernedChain(chain=my_chain)\n\n# Run with governance\nresponse = governed_chain.run(\"Hello world\")\n</code></pre>"},{"location":"integrations/#crewai","title":"CrewAI","text":"<p>Governance for CrewAI agents and crews:</p> <pre><code>from tork.adapters.crewai import TorkCrewAIMiddleware\n\nmiddleware = TorkCrewAIMiddleware()\ngoverned_agent = middleware.wrap_agent(my_agent)\n</code></pre>"},{"location":"integrations/#autogen","title":"AutoGen","text":"<p>Governance for Microsoft AutoGen agents and group chats:</p> <pre><code>from tork.adapters.autogen import TorkAutoGenMiddleware\n\nmiddleware = TorkAutoGenMiddleware()\ngoverned_agent = middleware.wrap_agent(my_agent)\n</code></pre>"},{"location":"integrations/#openai-agents-sdk","title":"OpenAI Agents SDK","text":"<p>The OpenAI Agents SDK integration provides comprehensive governance for OpenAI agents, including input/output filtering and tool call validation.</p>"},{"location":"integrations/#installation","title":"Installation","text":"<p>The OpenAI Agents adapter is an optional dependency:</p> <pre><code>pip install tork-governance[openai]\n</code></pre>"},{"location":"integrations/#basic-usage","title":"Basic Usage","text":"<pre><code>from tork.adapters.openai_agents import TorkOpenAIAgentsMiddleware\n\n# Initialize middleware\nmiddleware = TorkOpenAIAgentsMiddleware(agent_id=\"my-openai-agent\")\n\n# Wrap your agent\ngoverned_agent = middleware.wrap_agent(openai_agent)\n\n# Run with governance (supports sync and async)\nresult = governed_agent.run(\"Process this request\")\n# or\n# result = await governed_agent.run_async(\"Process this request\")\n</code></pre>"},{"location":"integrations/#features","title":"Features","text":"<ul> <li>wrap_agent: Intercepts <code>run</code> and <code>run_async</code> methods to apply governance.</li> <li>Tool Call Validation: Automatically blocks dangerous tool calls (shell, exec, etc.) based on security policies.</li> <li>Async Support: Full support for asynchronous agent execution.</li> <li>Compliance Receipts: Automatically generates signed audit receipts for all agent outputs.</li> </ul>"},{"location":"integrations/#http-proxy","title":"HTTP Proxy","text":"<p>Secure your API endpoints using the governance proxy:</p> <pre><code>from tork.adapters.http_proxy import GovernedProxy\n\nproxy = GovernedProxy(target_url=\"http://internal-api:8000\")\n# This creates a FastAPI app that filters requests/responses\n</code></pre>"},{"location":"integrations/#custom-policy-creation","title":"Custom Policy Creation","text":"<p>Policies are defined in YAML:</p> <pre><code>name: pii-protection\npriority: 10\nrules:\n  - field: \"user_message\"\n    operator: \"pii_detect\"\n    action: \"REDACT\"\n</code></pre>"},{"location":"personas/","title":"Personas","text":"<p>Custom AI agent personas with governance-enforced execution.</p>"},{"location":"personas/#overview","title":"Overview","text":"<p>The Personas module allows you to define, store, and execute custom AI personas with specific capabilities, system prompts, and governance settings. Each persona can have its own cost limits, allowed/blocked actions, and behavior constraints.</p>"},{"location":"personas/#core-concepts","title":"Core Concepts","text":""},{"location":"personas/#personacapability","title":"PersonaCapability","text":"<p>The 12 capability types a persona can have:</p> <pre><code>from tork.personas import PersonaCapability\n\nPersonaCapability.RESEARCH      # Information gathering\nPersonaCapability.ANALYSIS      # Data analysis\nPersonaCapability.CODING        # Code generation\nPersonaCapability.LEGAL         # Legal advice\nPersonaCapability.MEDICAL       # Medical information\nPersonaCapability.FINANCIAL     # Financial analysis\nPersonaCapability.CREATIVE      # Creative writing\nPersonaCapability.TECHNICAL     # Technical writing\nPersonaCapability.TRANSLATION   # Language translation\nPersonaCapability.SUMMARIZATION # Content summarization\nPersonaCapability.QA            # Question answering\nPersonaCapability.CONVERSATION  # General conversation\n</code></pre>"},{"location":"personas/#personaconfig","title":"PersonaConfig","text":"<p>Define a persona's configuration:</p> <pre><code>from tork.personas import PersonaConfig, PersonaCapability\n\nconfig = PersonaConfig(\n    id=\"legal-analyst\",\n    name=\"Legal Analyst\",\n    system_prompt=\"You are an expert legal analyst...\",\n    capabilities=[PersonaCapability.LEGAL, PersonaCapability.ANALYSIS],\n    max_cost_per_request=1.0,\n    allowed_actions=[\"analyze\", \"summarize\", \"cite\"],\n    blocked_actions=[\"provide_legal_advice\"],\n)\n</code></pre>"},{"location":"personas/#personastore","title":"PersonaStore","text":"<p>Persist and manage personas:</p> <pre><code>from tork.personas import PersonaStore\n\nstore = PersonaStore(storage_path=\"./personas\")\n\n# Save a persona\nstore.save(config)\n\n# Get a persona by ID\nconfig = store.get(\"legal-analyst\")\n\n# List all personas\nall_personas = store.list_all()\n\n# Filter by capability\nlegal_personas = store.filter_by_capability(PersonaCapability.LEGAL)\n\n# Delete a persona\nstore.delete(\"legal-analyst\")\n</code></pre>"},{"location":"personas/#importexport","title":"Import/Export","text":"<p>Share personas between systems:</p> <pre><code># Export to JSON\njson_data = store.export_json(\"legal-analyst\")\n\n# Export to YAML\nyaml_data = store.export_yaml(\"legal-analyst\")\n\n# Import from JSON\nstore.import_json(json_data)\n\n# Import from YAML\nstore.import_yaml(yaml_data)\n</code></pre>"},{"location":"personas/#personaruntime","title":"PersonaRuntime","text":"<p>Execute personas with governance:</p> <pre><code>from tork.personas import PersonaRuntime\n\nruntime = PersonaRuntime()\n\n# Register an executor for the persona's model\nruntime.register_executor(\"gpt-4\", gpt4_executor)\n\n# Execute the persona\nresult = runtime.execute(\n    persona_id=\"legal-analyst\",\n    input_text=\"Analyze this contract clause...\",\n    store=store,\n)\n\nprint(f\"Output: {result.output}\")\nprint(f\"Tokens: {result.tokens_used}\")\nprint(f\"Cost: ${result.cost}\")\n</code></pre>"},{"location":"personas/#session-tracking","title":"Session Tracking","text":"<p>Track persona usage across sessions:</p> <pre><code># Start a session\nsession = runtime.start_session(\"legal-analyst\", store)\n\n# Execute multiple requests\nresult1 = runtime.execute_in_session(session, \"First question...\")\nresult2 = runtime.execute_in_session(session, \"Follow-up...\")\n\n# Get session stats\nprint(f\"Total tokens: {session.total_tokens}\")\nprint(f\"Total cost: ${session.total_cost}\")\nprint(f\"Request count: {session.request_count}\")\n\n# End session\nruntime.end_session(session)\n</code></pre>"},{"location":"personas/#personabuilder","title":"PersonaBuilder","text":"<p>Fluent API for building personas:</p> <pre><code>from tork.personas import PersonaBuilder\n\nconfig = (\n    PersonaBuilder(\"code-reviewer\")\n    .with_name(\"Code Reviewer\")\n    .with_system_prompt(\"You are an expert code reviewer...\")\n    .with_capabilities([\n        PersonaCapability.CODING,\n        PersonaCapability.ANALYSIS,\n    ])\n    .with_max_cost(0.5)\n    .allow_actions([\"review\", \"suggest\", \"explain\"])\n    .block_actions([\"execute_code\", \"modify_files\"])\n    .with_metadata({\"language\": \"python\", \"style\": \"pep8\"})\n    .build()\n)\n</code></pre>"},{"location":"personas/#pre-built-templates","title":"Pre-built Templates","text":"<p>Ready-to-use persona configurations:</p> <pre><code>from tork.personas.templates import (\n    legal_analyst,\n    code_reviewer,\n    research_assistant,\n    content_writer,\n    data_analyst,\n    financial_advisor,\n)\n\n# Get a pre-configured legal analyst\nconfig = legal_analyst()\n\n# Get a code reviewer with custom settings\nconfig = code_reviewer(\n    languages=[\"python\", \"javascript\"],\n    max_cost=0.25,\n)\n\n# Get a research assistant\nconfig = research_assistant(\n    domains=[\"AI\", \"machine learning\"],\n)\n</code></pre>"},{"location":"personas/#governance-integration","title":"Governance Integration","text":"<p>Personas are governed by policies:</p> <pre><code>from tork.core import GovernanceEngine\n\ngov_engine = GovernanceEngine(policies=[pii_policy])\nruntime = PersonaRuntime(governance_engine=gov_engine)\n\n# PII in inputs/outputs will be redacted\n# Blocked actions will be denied\nresult = runtime.execute(\"legal-analyst\", \"Review this contract...\")\n</code></pre>"},{"location":"personas/#action-enforcement","title":"Action Enforcement","text":"<p>Personas can only perform allowed actions:</p> <pre><code>config = PersonaConfig(\n    id=\"safe-assistant\",\n    allowed_actions=[\"answer\", \"explain\"],\n    blocked_actions=[\"execute_code\", \"access_files\"],\n)\n\n# If persona tries to execute code, it will be blocked\nresult = runtime.execute(\"safe-assistant\", \"Run this Python code...\")\n# Result will contain a governance denial\n</code></pre>"},{"location":"personas/#compliance-receipts","title":"Compliance Receipts","text":"<p>Each execution generates a signed receipt:</p> <pre><code>result = runtime.execute(\"legal-analyst\", \"Analyze...\")\n\nreceipt = result.receipt\nprint(f\"Receipt ID: {receipt.receipt_id}\")\nprint(f\"Persona: {receipt.agent_id}\")\nprint(f\"Action: {receipt.action}\")\nprint(f\"Signature: {receipt.signature}\")\n</code></pre>"},{"location":"personas/#example-building-a-legal-review-system","title":"Example: Building a Legal Review System","text":"<pre><code>from tork.personas import PersonaStore, PersonaRuntime, PersonaBuilder\n\n# Create store and runtime\nstore = PersonaStore(\"./personas\")\nruntime = PersonaRuntime()\n\n# Build specialized personas\ncontract_reviewer = (\n    PersonaBuilder(\"contract-reviewer\")\n    .with_name(\"Contract Reviewer\")\n    .with_system_prompt(\"\"\"\n        You are an expert contract reviewer. Analyze contracts for:\n        - Unusual clauses\n        - Potential risks\n        - Missing standard provisions\n    \"\"\")\n    .with_capabilities([PersonaCapability.LEGAL, PersonaCapability.ANALYSIS])\n    .with_max_cost(2.0)\n    .build()\n)\n\n# Save to store\nstore.save(contract_reviewer)\n\n# Execute review\nresult = runtime.execute(\n    \"contract-reviewer\",\n    \"Please review this employment contract: ...\",\n    store,\n)\n\nprint(result.output)\n</code></pre>"},{"location":"prompts/","title":"Prompts","text":"<p>Agent-selectable prompts with multi-agent generation and selection.</p>"},{"location":"prompts/#overview","title":"Overview","text":"<p>The Prompts module enables multiple AI agents to generate prompt candidates, which are then scored and selected based on quality criteria. This allows for iterative prompt improvement and multi-perspective prompt engineering.</p>"},{"location":"prompts/#core-concepts","title":"Core Concepts","text":""},{"location":"prompts/#prompttype","title":"PromptType","text":"<p>Eight prompt types:</p> <pre><code>from tork.prompts import PromptType\n\nPromptType.SYSTEM       # System/persona prompts\nPromptType.USER         # User query prompts\nPromptType.ASSISTANT    # Assistant response templates\nPromptType.CRITIQUE     # Critique/feedback prompts\nPromptType.SYNTHESIS    # Combining multiple views\nPromptType.REFINEMENT   # Improving existing prompts\nPromptType.EXPANSION    # Adding detail\nPromptType.COMPRESSION  # Summarizing/condensing\n</code></pre>"},{"location":"prompts/#promptquality","title":"PromptQuality","text":"<p>Five quality levels:</p> <pre><code>from tork.prompts import PromptQuality\n\nPromptQuality.EXCELLENT    # Top tier (score &gt;= 0.85)\nPromptQuality.GOOD         # High quality (score &gt;= 0.70)\nPromptQuality.ACCEPTABLE   # Usable (score &gt;= 0.50)\nPromptQuality.POOR         # Below threshold (score &lt; 0.50)\nPromptQuality.REJECTED     # Safety issues (safety &lt; 0.50)\n</code></pre>"},{"location":"prompts/#promptcandidate","title":"PromptCandidate","text":"<p>A generated prompt with scores:</p> <pre><code>from tork.prompts import PromptCandidate, PromptType, PromptQuality\n\ncandidate = PromptCandidate(\n    prompt_type=PromptType.SYSTEM,\n    content=\"You are an expert assistant...\",\n    generator_agent=\"gpt-4\",\n    generator_model=\"gpt-4-turbo\",\n    quality=PromptQuality.GOOD,\n    clarity_score=0.85,\n    specificity_score=0.80,\n    safety_score=0.95,\n    token_count=50,\n)\n</code></pre>"},{"location":"prompts/#promptselectioncriteria","title":"PromptSelectionCriteria","text":"<p>Criteria for selecting prompts:</p> <pre><code>from tork.prompts import PromptSelectionCriteria, PromptQuality\n\ncriteria = PromptSelectionCriteria(\n    min_clarity=0.6,\n    min_specificity=0.5,\n    min_safety=0.8,\n    max_tokens=1000,\n    preferred_generators=[\"gpt-4\", \"claude-3\"],\n    blocked_generators=[\"untrusted-model\"],\n    prefer_quality=PromptQuality.GOOD,\n    clarity_weight=0.3,\n    specificity_weight=0.3,\n    safety_weight=0.4,\n)\n</code></pre>"},{"location":"prompts/#promptgenerator","title":"PromptGenerator","text":"<p>Generate prompts using agents:</p> <pre><code>from tork.prompts import PromptGenerator, PromptType\n\ngenerator = PromptGenerator()\n\n# Register agent executors\ndef gpt4_executor(meta_prompt):\n    # Call GPT-4 API\n    return {\"content\": response, \"model\": \"gpt-4\"}\n\ngenerator.register_executor(\"gpt-4\", gpt4_executor)\n\n# Generate a single prompt\ncandidate = generator.generate(\n    task=\"Create a customer service chatbot\",\n    prompt_type=PromptType.SYSTEM,\n    agent_id=\"gpt-4\",\n    context=\"E-commerce platform\",\n)\n\nprint(f\"Content: {candidate.content}\")\nprint(f\"Quality: {candidate.quality}\")\n</code></pre>"},{"location":"prompts/#generate-multiple-candidates","title":"Generate Multiple Candidates","text":"<pre><code># Generate from multiple agents\ncandidates = generator.generate_multiple(\n    task=\"Write a code review prompt\",\n    prompt_type=PromptType.SYSTEM,\n    agent_ids=[\"gpt-4\", \"claude-3\", \"gemini\"],\n)\n\nfor c in candidates:\n    print(f\"{c.generator_agent}: {c.quality.value}\")\n</code></pre>"},{"location":"prompts/#promptselector","title":"PromptSelector","text":"<p>Select the best prompt:</p> <pre><code>from tork.prompts import PromptSelector\n\nselector = PromptSelector()\n\n# Select best from candidates\nresult = selector.select(candidates, criteria)\n\nprint(f\"Selected: {result.selected.content}\")\nprint(f\"Confidence: {result.confidence}\")\nprint(f\"Reasoning: {result.selection_reasoning}\")\n</code></pre>"},{"location":"prompts/#rank-candidates","title":"Rank Candidates","text":"<pre><code># Get all candidates ranked by quality\nranked = selector.rank(candidates, criteria)\n\nfor i, candidate in enumerate(ranked, 1):\n    print(f\"{i}. {candidate.generator_agent}: {candidate.quality.value}\")\n</code></pre>"},{"location":"prompts/#promptorchestrator","title":"PromptOrchestrator","text":"<p>End-to-end prompt generation and selection:</p> <pre><code>from tork.prompts import PromptOrchestrator, PromptType\n\norchestrator = PromptOrchestrator()\n\n# Register executors\norchestrator.generator.register_executor(\"gpt-4\", gpt4_fn)\norchestrator.generator.register_executor(\"claude-3\", claude_fn)\n\n# Generate and select in one call\nresult = orchestrator.orchestrate(\n    task=\"Create an AI tutor prompt\",\n    prompt_type=PromptType.SYSTEM,\n    agent_ids=[\"gpt-4\", \"claude-3\"],\n    criteria=criteria,\n    context=\"For high school math students\",\n)\n\nprint(f\"Best prompt: {result.selected.content}\")\n</code></pre>"},{"location":"prompts/#refine-prompts","title":"Refine Prompts","text":"<p>Improve existing prompts:</p> <pre><code># Take a prompt and refine it\nrefined = orchestrator.refine(\n    prompt=result.selected,\n    refiner_agent=\"gpt-4\",\n    feedback=\"Make it more encouraging for struggling students\",\n)\n\nprint(f\"Refined: {refined.content}\")\nprint(f\"Original ID: {refined.metadata['original_id']}\")\n</code></pre>"},{"location":"prompts/#iterative-improvement","title":"Iterative Improvement","text":"<p>Keep refining until quality threshold:</p> <pre><code># Iterate until GOOD quality or max iterations\nresult = orchestrator.iterate(\n    task=\"Create a legal document analyzer\",\n    agent_ids=[\"gpt-4\", \"claude-3\"],\n    max_iterations=3,\n    criteria=PromptSelectionCriteria(prefer_quality=PromptQuality.GOOD),\n)\n\nprint(f\"Final quality: {result.selected.quality}\")\nprint(f\"Iterations: {result.total_evaluated}\")\n</code></pre>"},{"location":"prompts/#meta-prompt-templates","title":"Meta-Prompt Templates","text":"<p>Pre-built templates for generating prompts:</p> <pre><code>from tork.prompts import (\n    critique_meta_prompt,\n    synthesis_meta_prompt,\n    refinement_meta_prompt,\n    expansion_meta_prompt,\n    compression_meta_prompt,\n)\n\n# Generate a critique prompt\nmeta = critique_meta_prompt(\n    task=\"Review code for security vulnerabilities\",\n    context=\"Python web application\",\n)\n\n# Generate a synthesis prompt\nmeta = synthesis_meta_prompt(\n    task=\"Combine expert opinions on climate change\",\n)\n\n# Refine an existing prompt\nmeta = refinement_meta_prompt(\n    original=\"You are a helpful assistant.\",\n    feedback=\"Add expertise in data science\",\n)\n\n# Expand a brief prompt\nmeta = expansion_meta_prompt(\n    task=\"Answer questions\",\n    context=\"Customer support for a SaaS product\",\n)\n\n# Compress a verbose prompt\nmeta = compression_meta_prompt(\n    task=\"Very long and detailed prompt here...\",\n)\n</code></pre>"},{"location":"prompts/#scoring","title":"Scoring","text":"<p>Prompts are automatically scored on three dimensions:</p>"},{"location":"prompts/#clarity-score-0-1","title":"Clarity Score (0-1)","text":"<p>Based on sentence structure and readability:</p> <pre><code># Higher clarity:\n\"You are an expert Python developer. Your task is to review code for bugs.\"\n\n# Lower clarity:\n\"Do Python stuff with code things\"\n</code></pre>"},{"location":"prompts/#specificity-score-0-1","title":"Specificity Score (0-1)","text":"<p>Based on actionable details:</p> <pre><code># Higher specificity:\n\"You must identify security vulnerabilities including SQL injection, XSS, and CSRF.\"\n\n# Lower specificity:\n\"Find problems in the code\"\n</code></pre>"},{"location":"prompts/#safety-score-0-1","title":"Safety Score (0-1)","text":"<p>Penalized for unsafe patterns:</p> <pre><code># Prompts mentioning \"hack\", \"exploit\", \"bypass\", etc. get lower scores\n</code></pre>"},{"location":"prompts/#governance-integration","title":"Governance Integration","text":"<p>All generated prompts pass through governance:</p> <pre><code>from tork.core import GovernanceEngine\n\ngov_engine = GovernanceEngine(policies=[pii_policy])\ngenerator = PromptGenerator(governance_engine=gov_engine)\n\n# PII in generated prompts will be redacted\ncandidate = generator.generate(task, prompt_type, agent_id)\n</code></pre>"},{"location":"prompts/#example-prompt-engineering-pipeline","title":"Example: Prompt Engineering Pipeline","text":"<pre><code>from tork.prompts import (\n    PromptOrchestrator,\n    PromptType,\n    PromptSelectionCriteria,\n    PromptQuality,\n)\n\n# Set up orchestrator\norchestrator = PromptOrchestrator()\norchestrator.generator.register_executor(\"gpt-4\", gpt4_executor)\norchestrator.generator.register_executor(\"claude-3\", claude_executor)\n\n# Define quality criteria\ncriteria = PromptSelectionCriteria(\n    min_clarity=0.7,\n    min_specificity=0.6,\n    min_safety=0.9,\n    prefer_quality=PromptQuality.EXCELLENT,\n)\n\n# Generate candidates from multiple models\nresult = orchestrator.orchestrate(\n    task=\"Create a medical triage assistant that asks symptoms and suggests urgency\",\n    prompt_type=PromptType.SYSTEM,\n    agent_ids=[\"gpt-4\", \"claude-3\"],\n    criteria=criteria,\n    context=\"For a telemedicine app, must be cautious and recommend seeing doctors\",\n)\n\n# Check quality\nif result.selected.quality != PromptQuality.EXCELLENT:\n    # Refine until excellent\n    result = orchestrator.iterate(\n        task=result.selected.content,\n        agent_ids=[\"gpt-4\"],\n        max_iterations=2,\n        criteria=criteria,\n    )\n\nprint(f\"Final prompt: {result.selected.content}\")\nprint(f\"Quality: {result.selected.quality}\")\nprint(f\"Scores: clarity={result.selected.clarity_score}, specificity={result.selected.specificity_score}\")\n</code></pre>"},{"location":"quickstart/","title":"Quickstart Guide","text":"<p>Get started with Tork Governance in minutes.</p>"},{"location":"quickstart/#installation","title":"Installation","text":"<pre><code>pip install tork-governance\n</code></pre>"},{"location":"quickstart/#basic-usage","title":"Basic Usage","text":"<p>Evaluate a payload against a simple policy:</p> <pre><code>from tork.core.engine import GovernanceEngine\n\n# Initialize the engine\nengine = GovernanceEngine()\n\n# Evaluate a payload\npayload = {\"user_input\": \"My phone number is 555-123-4567\"}\nresult = engine.evaluate(payload)\n\nprint(f\"Decision: {result.decision}\")\nprint(f\"Modified Payload: {result.modified_payload}\")\n</code></pre>"},{"location":"quickstart/#running-the-playground","title":"Running the Playground","text":"<p>Start the interactive web UI to test your policies:</p> <p><pre><code>tork playground\n</code></pre> Then visit <code>http://localhost:5000</code> in your browser.</p>"},{"location":"quickstart/#cli-commands","title":"CLI Commands","text":"<p>Scan a directory for security vulnerabilities:</p> <pre><code># Scan a directory\ntork scan ./configs\n\n# Check the version\ntork --version\n</code></pre>"},{"location":"routing/","title":"Routing","text":"<p>Role and sector-based request routing with governance.</p>"},{"location":"routing/#overview","title":"Overview","text":"<p>The Routing module directs AI requests to appropriate agents based on the user's sector (industry) and role. Each route can have its own governance policy, allowed actions, and target persona.</p>"},{"location":"routing/#core-concepts","title":"Core Concepts","text":""},{"location":"routing/#sectors","title":"Sectors","text":"<p>11 industry sectors:</p> <pre><code>from tork.routing import Sector\n\nSector.EDUCATION      # Schools, universities\nSector.HEALTHCARE     # Hospitals, clinics\nSector.FINANCE        # Banks, investment\nSector.LEGAL          # Law firms, courts\nSector.TECHNOLOGY     # Software, IT\nSector.MARKETING      # Advertising, PR\nSector.RETAIL         # Stores, e-commerce\nSector.MANUFACTURING  # Factories, production\nSector.GOVERNMENT     # Public sector\nSector.NONPROFIT      # Charities, NGOs\nSector.GENERAL        # Default/other\n</code></pre>"},{"location":"routing/#roles","title":"Roles","text":"<p>24 user roles across sectors:</p> <pre><code>from tork.routing import Role\n\n# Education\nRole.STUDENT, Role.TEACHER, Role.ADMINISTRATOR\n\n# Healthcare\nRole.DOCTOR, Role.NURSE, Role.PATIENT\n\n# Finance\nRole.ANALYST, Role.TRADER, Role.ACCOUNTANT\n\n# Legal\nRole.LAWYER, Role.PARALEGAL, Role.CLIENT\n\n# Technology\nRole.DEVELOPER, Role.DEVOPS, Role.PRODUCT_MANAGER\n\n# And more...\nRole.EXECUTIVE, Role.MANAGER, Role.SUPPORT\n</code></pre>"},{"location":"routing/#routingcontext","title":"RoutingContext","text":"<p>Context for routing decisions:</p> <pre><code>from tork.routing import RoutingContext, Sector, Role\n\ncontext = RoutingContext(\n    sector=Sector.HEALTHCARE,\n    role=Role.DOCTOR,\n    user_id=\"dr-smith\",\n    permissions=[\"view_patient_data\", \"prescribe\"],\n    metadata={\"department\": \"cardiology\"},\n)\n</code></pre>"},{"location":"routing/#routeconfig","title":"RouteConfig","text":"<p>Define a route:</p> <pre><code>from tork.routing import RouteConfig\n\nroute = RouteConfig(\n    id=\"healthcare-doctor\",\n    target_agent=\"medical-assistant\",\n    target_persona=\"clinical-advisor\",\n    governance_policy=\"hipaa-compliant\",\n    allowed_actions=[\"diagnose_support\", \"drug_lookup\", \"cite_research\"],\n    blocked_actions=[\"prescribe\", \"diagnose_final\"],\n    max_cost=2.0,\n)\n</code></pre>"},{"location":"routing/#sectorrouter","title":"SectorRouter","text":"<p>Route requests based on context:</p> <pre><code>from tork.routing import SectorRouter\n\nrouter = SectorRouter()\n\n# Register routes\nrouter.register_route(\n    sector=Sector.HEALTHCARE,\n    roles=[Role.DOCTOR, Role.NURSE],\n    config=healthcare_route,\n)\n\n# Route a request\nresult = router.route(context, request=\"What are the symptoms of...\")\n\nprint(f\"Routed to: {result.target_agent}\")\nprint(f\"Using persona: {result.target_persona}\")\n</code></pre>"},{"location":"routing/#fallback-routes","title":"Fallback Routes","text":"<p>Handle unmatched requests:</p> <pre><code>router = SectorRouter(\n    fallback_route=RouteConfig(\n        id=\"default\",\n        target_agent=\"general-assistant\",\n    )\n)\n\n# If no sector/role match, uses fallback\nresult = router.route(unknown_context, request)\n</code></pre>"},{"location":"routing/#ruleengine","title":"RuleEngine","text":"<p>Flexible rule-based routing:</p> <pre><code>from tork.routing import RoutingRule, RuleEngine\n\nrule = RoutingRule(\n    id=\"high-value-finance\",\n    priority=10,\n    conditions={\n        \"sector\": Sector.FINANCE,\n        \"role\": Role.EXECUTIVE,\n        \"permission\": \"high_value_transactions\",\n    },\n    route_config=premium_finance_route,\n)\n\nengine = RuleEngine()\nengine.add_rule(rule)\n\n# Evaluate rules\nmatched_route = engine.evaluate(context)\n</code></pre>"},{"location":"routing/#rule-priorities","title":"Rule Priorities","text":"<p>Higher priority rules are evaluated first:</p> <pre><code># Priority 10 - checked first\nvip_rule = RoutingRule(id=\"vip\", priority=10, ...)\n\n# Priority 5 - checked second\nstandard_rule = RoutingRule(id=\"standard\", priority=5, ...)\n\n# First matching rule wins\nengine.add_rule(vip_rule)\nengine.add_rule(standard_rule)\n</code></pre>"},{"location":"routing/#default-sector-routes","title":"Default Sector Routes","text":"<p>Pre-configured routes for common sectors:</p> <pre><code>from tork.routing.defaults import (\n    education_routes,\n    healthcare_routes,\n    finance_routes,\n    legal_routes,\n    technology_routes,\n)\n\nrouter = SectorRouter()\n\n# Load all education routes\nfor route in education_routes():\n    router.register_route(Sector.EDUCATION, route.roles, route.config)\n\n# Load healthcare routes with HIPAA compliance\nfor route in healthcare_routes():\n    router.register_route(Sector.HEALTHCARE, route.roles, route.config)\n</code></pre>"},{"location":"routing/#default-route-characteristics","title":"Default Route Characteristics","text":"Sector Governance Policy Key Constraints Education content-appropriate Age-appropriate content Healthcare hipaa-compliant PII protection, medical disclaimers Finance financial-regulations No financial advice, disclosures Legal legal-disclaimers Not legal advice, jurisdiction limits Technology security-focused Code safety, no credentials"},{"location":"routing/#governance-per-route","title":"Governance Per Route","text":"<p>Each route can have its own policy:</p> <pre><code>from tork.core import GovernanceEngine\n\nroute = RouteConfig(\n    id=\"hipaa-route\",\n    governance_policy=\"hipaa-compliant\",\n    # This route uses stricter PII redaction\n)\n\n# Router applies route-specific governance\nresult = router.route(healthcare_context, request)\n# PII automatically redacted per HIPAA policy\n</code></pre>"},{"location":"routing/#example-multi-sector-application","title":"Example: Multi-Sector Application","text":"<pre><code>from tork.routing import SectorRouter, RoutingContext, Sector, Role, RouteConfig\n\n# Create router\nrouter = SectorRouter()\n\n# Education routes\nrouter.register_route(\n    sector=Sector.EDUCATION,\n    roles=[Role.STUDENT],\n    config=RouteConfig(\n        id=\"student-helper\",\n        target_persona=\"tutor\",\n        allowed_actions=[\"explain\", \"quiz\", \"encourage\"],\n        blocked_actions=[\"solve_homework\"],\n    ),\n)\n\nrouter.register_route(\n    sector=Sector.EDUCATION,\n    roles=[Role.TEACHER],\n    config=RouteConfig(\n        id=\"teacher-assistant\",\n        target_persona=\"curriculum-advisor\",\n        allowed_actions=[\"plan_lesson\", \"create_quiz\", \"grade_rubric\"],\n    ),\n)\n\n# Healthcare routes\nrouter.register_route(\n    sector=Sector.HEALTHCARE,\n    roles=[Role.DOCTOR],\n    config=RouteConfig(\n        id=\"clinical-support\",\n        target_persona=\"medical-reference\",\n        governance_policy=\"hipaa\",\n        allowed_actions=[\"lookup_drug\", \"cite_research\"],\n    ),\n)\n\n# Route based on user context\ndef handle_request(user_sector, user_role, request):\n    context = RoutingContext(sector=user_sector, role=user_role)\n    result = router.route(context, request)\n\n    # Execute with the matched persona/agent\n    return execute_with_persona(result.target_persona, request)\n</code></pre>"},{"location":"routing/#convenience-methods","title":"Convenience Methods","text":"<p>Quick routing shortcuts:</p> <pre><code># Route by sector only\nresult = router.route_by_sector(Sector.HEALTHCARE, request)\n\n# Route by role only\nresult = router.route_by_role(Role.DEVELOPER, request)\n\n# Get all routes for a sector\nroutes = router.get_sector_routes(Sector.FINANCE)\n</code></pre>"},{"location":"routing/#integration-with-personas","title":"Integration with Personas","text":"<p>Combine with the Personas module:</p> <pre><code>from tork.routing import SectorRouter\nfrom tork.personas import PersonaRuntime, PersonaStore\n\nrouter = SectorRouter()\nruntime = PersonaRuntime()\nstore = PersonaStore()\n\n# Route determines which persona to use\nresult = router.route(context, request)\n\n# Execute the matched persona\noutput = runtime.execute(\n    result.target_persona,\n    request,\n    store,\n)\n</code></pre>"},{"location":"workflows/","title":"Workflows","text":"<p>Agent chaining and workflow orchestration with governance.</p>"},{"location":"workflows/#overview","title":"Overview","text":"<p>The Workflows module enables you to define multi-step agent workflows where outputs from one step can be passed as inputs to the next. Each step is governed by policies and generates compliance receipts.</p>"},{"location":"workflows/#core-concepts","title":"Core Concepts","text":""},{"location":"workflows/#workflowstep","title":"WorkflowStep","text":"<p>A single step in a workflow:</p> <pre><code>from tork.workflows import WorkflowStep\n\nstep = WorkflowStep(\n    id=\"analyze\",\n    name=\"Analyze Data\",\n    agent_id=\"analyst-agent\",\n    input_mapping={\"data\": \"previous.output\"},\n    timeout_seconds=60,\n)\n</code></pre>"},{"location":"workflows/#workflowdefinition","title":"WorkflowDefinition","text":"<p>A complete workflow with multiple steps:</p> <pre><code>from tork.workflows import WorkflowDefinition\n\nworkflow = WorkflowDefinition(\n    id=\"research-pipeline\",\n    name=\"Research Pipeline\",\n    steps=[step1, step2, step3],\n    max_cost=10.0,\n)\n</code></pre>"},{"location":"workflows/#workflowengine","title":"WorkflowEngine","text":"<p>Execute workflows with governance:</p> <pre><code>from tork.workflows import WorkflowEngine\n\nengine = WorkflowEngine()\n\n# Register agent executors\nengine.register_executor(\"researcher\", research_fn)\nengine.register_executor(\"writer\", write_fn)\n\n# Execute the workflow\nresult = engine.execute(workflow, initial_input={\"topic\": \"AI Safety\"})\n</code></pre>"},{"location":"workflows/#workflowbuilder","title":"WorkflowBuilder","text":"<p>Fluent API for building workflows:</p> <pre><code>from tork.workflows import WorkflowBuilder\n\nworkflow = (\n    WorkflowBuilder(\"my-workflow\")\n    .add_step(\n        id=\"research\",\n        name=\"Research Topic\",\n        agent_id=\"researcher\",\n    )\n    .add_step(\n        id=\"write\",\n        name=\"Write Article\",\n        agent_id=\"writer\",\n        input_mapping={\"research\": \"research.output\"},\n    )\n    .add_step(\n        id=\"review\",\n        name=\"Review Article\",\n        agent_id=\"reviewer\",\n        input_mapping={\"article\": \"write.output\"},\n    )\n    .with_max_cost(5.0)\n    .build()\n)\n</code></pre>"},{"location":"workflows/#input-mapping","title":"Input Mapping","text":"<p>Pass outputs between steps:</p> <pre><code>step = WorkflowStep(\n    id=\"step2\",\n    name=\"Process\",\n    agent_id=\"processor\",\n    input_mapping={\n        \"data\": \"step1.output\",        # From step1's output\n        \"context\": \"initial.context\",   # From initial input\n    },\n)\n</code></pre>"},{"location":"workflows/#human-approval-gates","title":"Human Approval Gates","text":"<p>Pause workflows for human review:</p> <pre><code>step = WorkflowStep(\n    id=\"approve\",\n    name=\"Approval Gate\",\n    agent_id=\"human\",\n    requires_approval=True,\n)\n\n# Engine will pause at this step\nresult = engine.execute(workflow, {\"data\": \"...\"})\n\nif result.status == \"paused\":\n    # Get human approval\n    engine.resume(workflow.id, approved=True)\n</code></pre>"},{"location":"workflows/#failure-strategies","title":"Failure Strategies","text":"<p>Handle step failures:</p> <pre><code>from tork.workflows import FailureStrategy\n\nstep = WorkflowStep(\n    id=\"risky-step\",\n    failure_strategy=FailureStrategy.RETRY,\n    max_retries=3,\n)\n\n# Available strategies:\n# - STOP: Halt workflow on failure (default)\n# - SKIP: Skip failed step, continue\n# - RETRY: Retry with backoff\n# - FALLBACK: Use fallback agent\n</code></pre>"},{"location":"workflows/#cost-limits","title":"Cost Limits","text":"<p>Enforce budget constraints:</p> <pre><code>workflow = WorkflowDefinition(\n    id=\"budget-workflow\",\n    steps=[...],\n    max_cost=10.0,  # Stop if total cost exceeds $10\n)\n\n# Each step tracks tokens and cost\nresult = engine.execute(workflow, {...})\nprint(f\"Total cost: ${result.total_cost}\")\n</code></pre>"},{"location":"workflows/#pre-built-templates","title":"Pre-built Templates","text":"<p>Ready-to-use workflow patterns:</p> <pre><code>from tork.workflows.templates import (\n    research_critique_rewrite,\n    multi_agent_consensus,\n    review_and_approve,\n)\n\n# Research \u2192 Critique \u2192 Rewrite pipeline\nworkflow = research_critique_rewrite()\n\n# Multi-agent consensus workflow\nworkflow = multi_agent_consensus(agent_ids=[\"agent1\", \"agent2\", \"agent3\"])\n\n# Review and approval workflow\nworkflow = review_and_approve(reviewer_id=\"senior-reviewer\")\n</code></pre>"},{"location":"workflows/#compliance-receipts","title":"Compliance Receipts","text":"<p>Each step generates a signed receipt:</p> <pre><code>result = engine.execute(workflow, {...})\n\nfor step_result in result.step_results:\n    receipt = step_result.receipt\n    print(f\"Step: {step_result.step_id}\")\n    print(f\"Receipt ID: {receipt.receipt_id}\")\n    print(f\"Signature: {receipt.signature}\")\n</code></pre>"},{"location":"workflows/#async-execution","title":"Async Execution","text":"<p>Execute workflows asynchronously:</p> <pre><code>async def run_workflow():\n    engine = WorkflowEngine()\n    result = await engine.execute_async(workflow, {\"data\": \"...\"})\n    return result\n</code></pre>"}]}